# Общие рекомендации
1) Наличие папок **Domain** и **Infrastructure** намекает на слоистую архитектуру.\
   В таком случае необходимо папки **Repository**, **View**, **Controller** перенести в папку **Infrastructure**, а также создать слой **Application** с юзкейсами приложения

2) Непонятно зачем в **Repository** находится **Entity/Product.php**, наверное стоит его перенести в **Domain**

3) Не передан файл `composer.lock`, нужно убрать его из `.gitignore` и запушить в репозиторий, чтобы залокать зависимости

4) Оба **View** обращается напрямую в репозиторий, он должен отвечать только за представление полученных данных, а не за их вычисление и наполнение

5) Также можно сделать отдельные **DTO-классы** для Request-ов в контроллере, так будет проще работать с полями запроса на всех слоях приложения

# Обзор файлов

## Controller

### 1. AddToCartController.php

1) Слишком много лишней ответственности у контроллера:

    - Обращается в репозиторий для получения корзины
    - Обращается в репозиторий для получения продукта по **uuid**
    - Создаёт **CartItem**

2) Эндпоинт создаёт сущность, но возвращается `HTTP 200 OK`, а должен `HTTP 201 CREATED`
3) Возвращается поле `status => success`, но зачем, если достаточно HTTP кода ответа

### 2. GetCartController.php

1) Обрабатывается случай когда `cart === null`, но **getCart** в любом случае возвращает корзину: либо существующую, либо пустую (но тут больше косяк **CartManager**, так как прописано, что он может вернуть null)
2) Всегда возвращается **404**, даже если корзина найдена

### 3. GetProductsController.php
Если учесть, что валидация категории была до вызова контроллера (в том числе на существование), то:
1) Не учитывается, что категория может быть пустой, тогда нужно возвращать **HTTP 204 NO CONTENT**
2) Во View передаётся просто категория, и уже в нём считываются продукты. Необходимо сразу передавать в него список продуктов

### 4. JsonResponse.php
Класс заглушка - не обращаем внимания

## View

### 1. CartView.php

1) Обращается в репозиторий для считывания данных - ❌ незя
2) Занимается вычислением **total**, чего делать не должен
3) Неправильно вычисляет **total** - считывается из кэша, где может быть устаревшая цена. \
   Раз уж идёт обращение к продуктам в БД, то можно вытаскивать цену оттуда

### 2. ProductView.php

1) Обращается в репозиторий для считывания данных - ❌ незя. Должен сразу получать массив продуктов, и работать с ним
2) Стрелочную функцию можно сделать `static` - будет легковеснее

## Repository

### 1. Entity/Product.php

Нужно переместить в Domain

### 2. CartManager.php

1) Зачем-то наследуется от ConnectorFacade, никак его не расширяя. Получить доступ к **Connector** можно и по-другому
2) Заполнение поля стоит вынести в конструктор, чтобы за его наполнение не отвечали зависящие от **CartManager** классы
3) Также может упасть ошибка при попытке обращения к полю Logger, так как оно может быть не задано
4) Убрать `inheritdoc` у метода saveCart
5) Не хватает типизации в полях конструктора
6) Не хватает возвращаемого типа в методах **saveCart** и **getCart**. Для **getCart** также стоит убрать аннотацию
7) Метод getCart не передаёт все поля в конструктор корзины - он попросту её не создаст

### 3. ProductRepository.php

1) Нет защиты от SQL-инъекций
2) Метод **getByCategory** стоит назвать **getActiveByCategory**, так как он возвращает только активные продукты.
3) Метод **getByCategory** селектит только поле **id**, а должен все поля, так как их требует функция make.
4) В конструкторе можно сразу создать поле `$connection`,
5) Стоит сделать более явное название для make, так как **непонятно**, что он создаёт _продукт из строки БД_. Можно назвать как-нибудь `mapRowToProduct` или хотя-бы `makeProduct`
6) Метод **make** можно сделать приватным, так как он может использоваться только в этом методе

## Infrastructure

### 1. Connector.php

1) Можно создавать поле `$redis` сразу через аргументы конструктора
2) Нужно убрать `return` из конструктора
3) Метод **get** ищет корзину по ключу с типом `Cart`, хотя сохраняются они по строковому ключу (и метода __toString в Cart нет)
4) В целом плохая практика хранить сериализованные объекты, можно использовать JSON
5) Можно переименовать в RedisConnector, так как класс работает только с Redis

### 2. ConnectorException.php

1) Можно отнаследоваться от \Exception и уменьшит его во много раз и при этом ничего не потерять.

### 3. ConnectorFacade.php

1) Можно создавать поля класса сразу через аргументы конструктора
2) Это не паттерн фасад, а скорее билдер, так как он занимается созданием **Connector** объекта
3) Создаваемый Connector в методе `build` никак не возвращается
4) Поле $connector с видимостью public - не есть хорошо. И в целом можно обойтись без этого поля, так как при вызове build каждый раз создаётся новый объект
5) В методе `build` не логируется и не обрабатывается RedisException
6) Метод `build` не возвращает объект Connector, а просто меняет своё поле `$connector`

## Domain

### 1. Cart.php

1) К полю можно добавить дженерик, чтобы обозначить, что требуется массив именно **CartItem объектов**
2) readonly модификатор должен быть после private (readlonly private => private readonly) - PER 3

### 2. CartItem.php

1) Класс readonly с публичными полями => можно либо убрать все геттеры полей (можно обойтись без них), либо сделать поля приватными и их оставить
2) Цену лучше хранить в `int`, и указывать её в копейках/центах и т.п.

### 3. Customer.php

### migartions

Индекс по is_active малоэффективен, так как обладает низкой селективностью.\
Стоит сделать индексы по другим полям, например по `category` и `uuid`, так как по ним часто ищутся товары и они обладают большей селективностью